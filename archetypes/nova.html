<!doctype html>
<html lang="pt-BR">
<meta charset="utf-8">
<title>Nova • Icosaedro</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  :root {
    --bg: transparent;        /* fundo transparente para integrar com overlay do host */
    --line: #8fd3ff;          /* cor principal Blue‑1 */
    --glow: 24px;             /* força de glow base */
    --bloom: 1;               /* multiplica o blur/sombra para um look mais fotográfico */
    --lineWidth: 1.6;         /* espessura */
    --rotateSpeed: 0.6;       /* rotações por segundo */
  }
  html,body {height:100%}
  body { margin:0; background:var(--bg); overflow:hidden; color:#eaf6ff; font:14px/1.4 ui-sans-serif, system-ui; }
  canvas { position:fixed; inset:0; width:100%; height:100%; display:block; }
  .label {
     position:fixed; left:0; right:0; bottom:10px; text-align:center; 
     letter-spacing:.08em; text-transform:uppercase; font-weight:600; opacity:.8;
     text-shadow:0 0 8px #35b6ff, 0 0 20px #35b6ff;
     pointer-events:none;
  }
</style>
<canvas id="solid"></canvas>
<div class="label">Nova — Icosaedro</div>
<script>
(function() {
  // ========= util =========
  const TAU = Math.PI*2;
  const φ = (1+Math.sqrt(5))/2;
  const canvas = document.getElementById('solid');
  const ctx = canvas.getContext('2d');

  function size() {
    const dpr = window.devicePixelRatio||1;
    canvas.width  = Math.floor(innerWidth*dpr);
    canvas.height = Math.floor(innerHeight*dpr);
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    return dpr;
  }
  let DPR = size();
  addEventListener('resize', () => DPR = size());

  // ========= geometry =========
  function solidData(kind) {
    // returns {verts: [x,y,z][], edges: [i,j][]}
    if (kind==='tetra') {
      const v = [
        [ 1, 1, 1],
        [-1,-1, 1],
        [-1, 1,-1],
        [ 1,-1,-1]
      ];
      const e = [[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]];
      return {verts:v, edges:e};
    }
    if (kind==='hexa') { // cube
      const v = [];
      for (let x of [-1,1]) for (let y of [-1,1]) for (let z of [-1,1]) v.push([x,y,z]);
      const id = (x,y,z)=> (x+1)/2*4 + (y+1)/2*2 + (z+1)/2;
      const e = [];
      const xs=[-1,1], ys=[-1,1], zs=[-1,1];
      for (let xi=0; xi<2; xi++) for (let yi=0; yi<2; yi++) {
        e.push([id(xs[xi],ys[yi],-1), id(xs[xi],ys[yi],1)]);
      }
      for (let xi=0; xi<2; xi++) for (let zi=0; zi<2; zi++) {
        e.push([id(xs[xi],-1,zs[zi]), id(xs[xi],1,zs[zi])]);
      }
      for (let yi=0; yi<2; yi++) for (let zi=0; zi<2; zi++) {
        e.push([id(-1,ys[yi],zs[zi]), id(1,ys[yi],zs[zi])]);
      }
      return {verts:v, edges:e};
    }
    if (kind==='octa') {
      const v = [
        [ 1, 0, 0],[-1, 0, 0],
        [ 0, 1, 0],[ 0,-1, 0],
        [ 0, 0, 1],[ 0, 0,-1]
      ];
      const e = [[0,2],[0,3],[0,4],[0,5],[1,2],[1,3],[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]];
      return {verts:v, edges:e};
    }
    if (kind==='icosa') {
      const t = φ;
      const v = [
        [-1, t, 0],[ 1, t, 0],[-1,-t, 0],[ 1,-t, 0],
        [ 0,-1, t],[ 0, 1, t],[ 0,-1,-t],[ 0, 1,-t],
        [ t, 0,-1],[ t, 0, 1],[-t, 0,-1],[-t, 0, 1]
      ];
      // normalized
      for(let i=0;i<v.length;i++) {
        const [x,y,z]=v[i]; const m=Math.hypot(x,y,z); v[i]=[x/m,y/m,z/m];
      }
      const e = [
        [0,1],[0,5],[0,7],[0,10],[0,11],
        [1,5],[1,7],[1,8],[1,9],
        [2,3],[2,4],[2,6],[2,10],[2,11],
        [3,4],[3,6],[3,8],[3,9],
        [4,5],[4,9],[4,11],
        [5,9],[5,11],
        [6,7],[6,8],[6,10],
        [7,8],[7,10],
        [8,9],[10,11]
      ];
      return {verts:v, edges:e};
    }
    if (kind==='dodeca') {
      const t = φ;
      // Build from icosa dual. Dodeca vertices are permutations of (±1, ±1, ±1), (0, ±1/φ, ±φ), (±1/φ, ±φ, 0), (±φ, 0, ±1/φ)
      const a = 1/ t;
      const b = t;
      const v = [];
      // (±1, ±1, ±1)
      for (let x of [-1,1]) for (let y of [-1,1]) for (let z of [-1,1]) v.push([x,y,z]);
      // (0, ±a, ±b)
      for (let y of [-a,a]) for (let z of [-b,b]) v.push([0,y,z]);
      for (let y of [-b,b]) for (let z of [-a,a]) v.push([0,y,z]); // (0, ±b, ±a)
      // (±a, ±b, 0)
      for (let x of [-a,a]) for (let y of [-b,b]) v.push([x,y,0]);
      for (let x of [-b,b]) for (let y of [-a,a]) v.push([x,y,0]); // (±b, ±a,0)
      // (±a,0,±b)
      for (let x of [-a,a]) for (let z of [-b,b]) v.push([x,0,z]);
      for (let x of [-b,b]) for (let z of [-a,a]) v.push([x,0,z]); // (±b,0,±a)
      // normalize a bit
      for(let i=0;i<v.length;i++) { const [x,y,z]=v[i]; const m=Math.hypot(x,y,z); v[i]=[x/m,y/m,z/m]; }
      // edges from standard dodeca connectivity (approximate selection to keep wireframe coherent)
      // We'll compute edges by connecting vertices whose distance is close for a dodecahedron.
      const edges=[]; 
      for(let i=0;i<v.length;i++) for(let j=i+1;j<v.length;j++) {
        const [x1,y1,z1]=v[i], [x2,y2,z2]=v[j];
        const d = Math.hypot(x1-x2,y1-y2,z1-z2);
        if (d>0.9 && d<1.35) edges.push([i,j]); // heuristic
      }
      // Limit to a manageable number by removing far edges when too many
      if (edges.length>100) edges.length=100;
      return {verts:v, edges:edges};
    }
    return solidData('octa');
  }

  const params = new URLSearchParams(location.search);
  const kind = (params.get('solid') || 'icosa').toLowerCase();
  const glow = Math.max(0, Math.min(1.5, parseFloat(params.get('glow')||'0.8')));
  const bloom = Math.max(0, Math.min(3, parseFloat(params.get('bloom')||'1.0')));
  const lineW = Math.max(0.5, Math.min(4, parseFloat(params.get('lw')||getComputedStyle(document.documentElement).getPropertyValue('--lineWidth'))));
  const rotateSpeed = parseFloat(params.get('rs')||getComputedStyle(document.documentElement).getPropertyValue('--rotateSpeed'));
  const {verts, edges} = solidData(kind);

  // ========= camera & project =========
  let angleX=0, angleY=0;
  function rot([x,y,z], ax, ay) {
    // rotate first around Y (ay), then X (ax)
    const cy=Math.cos(ay), sy=Math.sin(ay), cx=Math.cos(ax), sx=Math.sin(ax);
    let nx =  cy*x + sy*z;
    let nz = -sy*x + cy*z;
    let ny =  cx*y - sx*nz;
    nz =  sx*y + cx*nz;
    return [nx,ny,nz];
  }
  let audioLevel = 0;
  window.addEventListener('message', (e)=>{
     if (e && e.data && typeof e.data.audioLevel==='number') audioLevel = e.data.audioLevel;
  });

  // ========= draw =========
  function draw(t) {
    const w=canvas.width, h=canvas.height;
    ctx.clearRect(0,0,w,h);
    // breathing scale
    const baseS = Math.min(w,h)*0.32;
    const breathe = 1 + 0.10*Math.sin(t*0.002) + 0.35*audioLevel;
    const s = baseS * breathe;

    angleX = t*0.001*TAU*rotateSpeed*0.2;
    angleY = t*0.001*TAU*rotateSpeed*0.3;

    // project
    const proj = [];
    for (let i=0; i<verts.length; i++) {
      const [x,y,z] = rot(verts[i], angleX, angleY);
      const d = 3/(z+3.8); // simple perspective
      proj.push([ w/2 + x*s*d, h/2 + y*s*d, d ]);
    }

    // glow layers
    ctx.lineCap='round';
    ctx.lineJoin='round';
    const baseAlpha = 0.85;
    const layers = 4;
    for (let L=layers; L>=1; L--) {
      ctx.beginPath();
      for (const [i,j] of edges) {
        const [x1,y1] = proj[i], [x2,y2] = proj[j];
        ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
      }
      ctx.strokeStyle = 'rgba(143,211,255,'+(baseAlpha*(L/layers))+')';
      ctx.lineWidth = (lineW + (L-1)*1.2) * DPR;
      ctx.shadowColor = 'rgba(53,182,255,'+(0.45*glow*(L/layers))+')';
      ctx.shadowBlur = (10 + 18*L) * glow * bloom * DPR;
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    // core crisp lines
    ctx.beginPath();
    for (const [i,j] of edges) {
      const [x1,y1] = proj[i], [x2,y2] = proj[j];
      ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
    }
    ctx.strokeStyle = 'rgba(220,245,255,0.92)';
    ctx.lineWidth = lineW * DPR;
    ctx.stroke();

    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
})();
</script>


<!-- UNO • 3D Bloom+Toon overlay injection (auto) -->
<style>
#uno3d-wrap {position:absolute; inset:0; pointer-events:none; z-index: 20;}
#uno3d {width:100%; height:100%; display:block;}
/* Keep any existing 2D canvas behind */
canvas#c { position:absolute; inset:0; z-index: 5; }
</style>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.155.0/build/three.module.js';
import { EffectComposer } from 'https://unpkg.com/three@0.155.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://unpkg.com/three@0.155.0/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://unpkg.com/three@0.155.0/examples/jsm/postprocessing/UnrealBloomPass.js';
import { RGBELoader } from 'https://unpkg.com/three@0.155.0/examples/jsm/loaders/RGBELoader.js';

const ARCH_KEY = 'nova';
const MAP = {"atlas": {"kind": "cube", "color": "#409eff"}, "nova": {"kind": "icosa", "color": "#ff52b1"}, "vitalis": {"kind": "tetra", "color": "#34d399"}, "pulse": {"kind": "octa", "color": "#f472b6"}, "artemis": {"kind": "dodeca", "color": "#22d3ee"}, "serena": {"kind": "octa", "color": "#a78bfa"}, "kaos": {"kind": "tetra", "color": "#ff4d6d"}, "genus": {"kind": "dodeca", "color": "#57cf70"}, "lumine": {"kind": "icosa", "color": "#ffd54f"}, "rhea": {"kind": "octa", "color": "#00d1b2"}, "solus": {"kind": "dodeca", "color": "#b691ff"}, "aion": {"kind": "icosa", "color": "#ff9f43"}, "default": {"kind": "cube", "color": "#ffffff"}};
const CFG = MAP[ARCH_KEY] || MAP.default;
const BASE_COLOR = new THREE.Color(CFG.color);
document.documentElement.style.setProperty('--line', CFG.color);

const wrap = document.createElement('div');
wrap.id = 'uno3d-wrap';
const canvas = document.createElement('canvas');
canvas.id = 'uno3d';
wrap.appendChild(canvas);
document.body.appendChild(wrap);

const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
renderer.setPixelRatio(Math.min(devicePixelRatio||1, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
renderer.shadowMap.enabled = false;

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(36, innerWidth/innerHeight, 0.1, 50);
camera.position.set(0, 0.2, 3.4);

scene.add(new THREE.AmbientLight(0xffffff, 0.22));
const hemi = new THREE.HemisphereLight(0xa0b8ff, 0x0b0f14, 0.9);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 1.2);
dir.position.set(2.5, 3.5, 2.0);
dir.castShadow = false;
scene.add(dir);

const pmrem = new THREE.PMREMGenerator(renderer);
pmrem.compileEquirectangularShader();
new RGBELoader().setDataType(THREE.FloatType)
  .load('https://unpkg.com/three@0.155.0/examples/textures/equirectangular/royal_esplanade_1k.hdr', (hdr)=>{ 
    const env = pmrem.fromEquirectangular(hdr).texture;
    scene.environment = env;
    hdr.dispose(); pmrem.dispose();
  });

function geo(kind) { 
  switch(kind){
    case 'cube': return new THREE.BoxGeometry(1.2,1.2,1.2, 1,1,1);
    case 'tetra': return new THREE.TetrahedronGeometry(1.2,0);
    case 'octa': return new THREE.OctahedronGeometry(1.2,0);
    case 'icosa': return new THREE.IcosahedronGeometry(1.2,0);
    case 'dodeca': return new THREE.DodecahedronGeometry(1.2,0);
    default: return new THREE.IcosahedronGeometry(1.2,0);
  }
}

const material = new THREE.MeshStandardMaterial({ 
  color: BASE_COLOR, metalness: 0.68, roughness: 0.22, envMapIntensity: 1.2, 
  emissive: BASE_COLOR.clone().multiplyScalar(0.03), emissiveIntensity: 1.0, 
  clearcoat: 0.3, clearcoatRoughness: 0.4
});

const g = geo(CFG.kind);
const mesh = new THREE.Mesh(g, material);
scene.add(mesh);

// Neon edges
const edges = new THREE.EdgesGeometry(g, 20);
const lineMat = new THREE.LineBasicMaterial({ color: CFG.color, transparent: true, opacity: 0.85 });
const wire = new THREE.LineSegments(edges, lineMat);
wire.scale.setScalar(1.003);
scene.add(wire);

// Post FX
const composer = new EffectComposer(renderer);
const renderPass = new RenderPass(scene, camera);
composer.addPass(renderPass);
const bloomStrength = Math.max(0.0, Math.min(2.0, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--bloom')) || 1.0));
const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.8*bloomStrength, 0.55, 0.18);
composer.addPass(bloom);

function onResize(){
  const w = innerWidth, h = innerHeight;
  renderer.setSize(w,h);
  composer.setSize(w,h);
  camera.aspect = w/h; camera.updateProjectionMatrix();
}
addEventListener('resize', onResize);

// Audio reactive
let audioLevel = 0;
addEventListener('message', (e)=>{
  const d = e && e.data;
  if (d && typeof d.audioLevel === 'number'){ audioLevel = Math.max(0, Math.min(1, d.audioLevel)); }
}, false);

let t0 = performance.now();
function animate(now){
  requestAnimationFrame(animate);
  const dt = (now - t0)/1000; t0 = now;
  const rs = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--rotateSpeed')) || 0.6;
  mesh.rotation.y += rs * 0.7 * dt;
  mesh.rotation.x += rs * 0.24 * dt;
  wire.rotation.copy(mesh.rotation);
  // Pulse
  const s = 1.0 + audioLevel*0.12;
  mesh.scale.setScalar(s);
  wire.scale.setScalar(s*1.003);
  material.emissiveIntensity = 0.6 + audioLevel*1.8;
  composer.render();
}
requestAnimationFrame(animate);

// Optional: expose for tuning via devtools
window.__UNO3D__ = { scene, camera, renderer, composer, mesh, wire, bloom };
</script>
